#version 150
bool check_alpha(float textureAlpha,float targetAlpha){float targetLess=targetAlpha-0.01;float targetMore=targetAlpha+0.01;return textureAlpha>targetLess&&textureAlpha<targetMore;}vec4 apply_partial_emissivity(vec4 inputColor,vec4 originalLightColor,vec3 minimumLightColor){vec4 newLightColor=originalLightColor;newLightColor.r=max(originalLightColor.r,minimumLightColor.r);newLightColor.g=max(originalLightColor.g,minimumLightColor.g);newLightColor.b=max(originalLightColor.b,minimumLightColor.b);return inputColor*newLightColor;}vec4 make_emissive(vec4 inputColor,vec4 lightColor,vec4 maxLightColor,float vertexDistance,float inputAlpha){if(vertexDistance>800)return inputColor;if(check_alpha(inputAlpha,252.))return inputColor;else if(check_alpha(inputAlpha,251.))return apply_partial_emissivity(inputColor,lightColor,vec3(0.411,0.345,0.388));else if(check_alpha(inputAlpha,250.))return inputColor;else if(check_alpha(inputAlpha,140.))return inputColor;else if(check_alpha(inputAlpha,210.))return inputColor;else if(check_alpha(inputAlpha,180.))return inputColor;else if(check_alpha(inputAlpha,80.))return inputColor;else if(check_alpha(inputAlpha,50.))return inputColor;else if(check_alpha(inputAlpha,25.))return inputColor;else if(check_alpha(inputAlpha,200.))return inputColor;else if(check_alpha(inputAlpha,235.))return inputColor;else return inputColor*lightColor;}float get_dimension(vec4 minLightColor){if(minLightColor.r==minLightColor.g&&minLightColor.g==minLightColor.b)return 0.;else if(minLightColor.r>minLightColor.g)return -1.;else return 1.;}vec4 get_face_lighting(vec3 normal,float dimension){vec4 faceLighting=vec4(1.,1.,1.,1.);vec3 absNormal=abs(normal);float top=229./255.;float bottom=127./255.;float east=153./255.;float north=204./255.;if(normal.y>normal.z&&normal.y>normal.x&&check_alpha(dimension,-1.))faceLighting=vec4(top,top,top,1.);if(normal.y<normal.z&&normal.y<normal.x&&!check_alpha(dimension,-1.))faceLighting=vec4(bottom,bottom,bottom,1.);else if(normal.y<normal.z&&normal.y<normal.x&&check_alpha(dimension,-1.))faceLighting=vec4(top,top,top,1.);if(absNormal.x>absNormal.z&&absNormal.x>absNormal.y)faceLighting=vec4(east,east,east,1.);if(absNormal.z>absNormal.x&&absNormal.z>absNormal.y)faceLighting=vec4(north,north,north,1.);return faceLighting;}vec4 face_lighting_check(vec3 normal,float inputAlpha,float dimension){if(check_alpha(inputAlpha,250.))return get_face_lighting(normal,dimension);else return vec4(1.,1.,1.,1.);}float remap_alpha(float inputAlpha){if(check_alpha(inputAlpha,252.))return 255.;else if(check_alpha(inputAlpha,251.))return 190.;else if(check_alpha(inputAlpha,250.))return 255.;else return inputAlpha;}